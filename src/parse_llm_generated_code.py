import os
import argparse
import json

# custom imports
from tree_sitter_parser import initialize_parser, read_source_code, extract_functions_globals_headers, print_information
import re
from string_utils import fix_json_like_string, fix_single_backslashes




def extract_code(filename):
    with open(filename, 'r') as file:
        content = file.read()
    
    language = re.search(r'Language: (.*)\n', content).group(1)

    # Extract all code blocks
    code_blocks = re.findall(r'```(.*?)```', content, re.DOTALL)

    # Concatenate all code blocks
    code = '\n'.join(code_blocks)

    return code, language

# argparser = argparse.ArgumentParser(description='Parse the code generated by the LLM model')
# argparser.add_argument('filename', type=str, help='The filename of the generated code')
# args = argparser.parse_args()

# # Extract the code and language
# code, language = extract_code(args.filename)



#code, language = extract_code('/home/newdrive/makil/projects/GenAI_Malware_Repository/development_code/selected_samples/exeinfector/codestral:latest_response_2.txt')

# create a temporary file to write the code with the correct extension


def extract_outermost_json(text):
    brace_count = 0
    start_index = None

    for i, char in enumerate(text):
        if char == '{':
            if brace_count == 0:
                start_index = i
            brace_count += 1
        elif char == '}':
            brace_count -= 1
            if brace_count == 0:
                end_index = i
                return text[start_index:end_index + 1]

    return None

def parse_json_from_llm_response_file(file_path, language):
    with open(file_path, 'r') as file:
        llm_response = file.read()
        #print(llm_response)
    
        parse_json_from_llm_response(llm_response, language)
        
def parse_json(json_string):
    print(f'JSON STRING BEFORE PARSING: {json_string}')
    print(f'Type to be parsed: {type(json_string)}')
    
    # replacing \\n to \n
    json_string = json_string.replace('\\\\n', '\\n')
    
    # # fix if json is illformed
    # print("FIXING JSON LIKE STRING IF IT IS ILL FORMED!!")
    # json_string = fix_json_like_string(json_string)
    
    # print(f'JSON string: {json_string}')
    
    try:
        json_object = json.loads(json_string)
        
        # print(json_object['modified code'])
        
        # if 'mapping' in json_object:
        #     print(json_object['mapping'])
            
        return json_object
        
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON INNNN: {e}")
        
        return None

def parse_json_from_llm_response(llm_response, language):
    # Adjust the regular expression to correctly match the JSON object enclosed in ```json ```
    print(f"Trying to parse JSON object from the response. Response type is : {type(llm_response)}\n")
    json_match = re.search(r'```json\s+(.*?)\s+```', llm_response, re.DOTALL)
    result_json_object = None
    
    if json_match:
        json_string = json_match.group(1)
        print(json_string)
        result_json_object = parse_json(json_string)
    else:
        print("No JSON object with ```json ``` found in the response. Trying with counting braces")
        
        outermost_json_string = extract_outermost_json(llm_response)
        result_json_object = parse_json(outermost_json_string)
    
    return result_json_object

def parse_code_any_format(llm_response, language, source_code_response_format='backticks'):
    
    code = None
    mapping_information = None
    
    if source_code_response_format == 'json':
        
        result_json_object = parse_json_from_llm_response(llm_response, language)
        
        if result_json_object is None:
            return None, None
        
        code = result_json_object['modified code'] if 'modified code' in result_json_object else None
        mapping_information = result_json_object['replacer'] if 'replacer' in result_json_object else None
        
    elif source_code_response_format == 'backticks':
        # Extract all code blocks
        code_blocks = re.findall(r'```(.*?)```', llm_response, re.DOTALL)
        # Concatenate all code blocks
        code = ''.join(code_blocks)
        
        lines_of_code_generated = len(code.strip().split('\n')) - 1
        
        # result_json_object = parse_json_from_llm_response(llm_response, language)
        # mapping_information = result_json_object['mapping'] if 'mapping' in result_json_object else None
        
        # print(f"MAPPING: {mapping_information}")
    
    
    # fix the code if there are errors with escape characters in the code
    if code is None or code == '':
        return None, 0, None

    #print(f"Code before fixing: {code}")
    
    code = fix_single_backslashes(code)
    
    # create a temporary file to write the code with the correct extension
    temp_source_code_file = 'temp.' + language
    with open(temp_source_code_file, 'w') as file:
        file.write(code)

    parser = initialize_parser(temp_source_code_file)

    # Read the source code
    temp_source_code = read_source_code(temp_source_code_file)
    tree = parser.parse(bytes(temp_source_code, 'utf8'))

    # Extract functions, globals, and headers
    segmented_code = extract_functions_globals_headers(temp_source_code, tree)

    # Print the extracted information
    #print_information(parsed_info)

    # delete the temporary file
    #os.remove(temp_source_code_file)
    
    return segmented_code, lines_of_code_generated, mapping_information
        
        

def parse_code(llm_response, language):
    # Extract all code blocks
    code_blocks = re.findall(r'```(.*?)```', llm_response, re.DOTALL)
    

    # Concatenate all code blocks
    code = '\n'.join(code_blocks)
    
    # create a temporary file to write the code with the correct extension
    temp_source_code_file = 'temp.' + language
    with open(temp_source_code_file, 'w') as file:
        file.write(code)

    parser = initialize_parser(temp_source_code_file)

    # Read the source code
    temp_source_code = read_source_code(temp_source_code_file)
    tree = parser.parse(bytes(temp_source_code, 'utf8'))

    # Extract functions, globals, and headers
    parsed_info = extract_functions_globals_headers(temp_source_code, tree)

    # Print the extracted information
    #print_information(parsed_info)

    # delete the temporary file
    os.remove(temp_source_code_file)
    
    return parsed_info
    
    
# temp_source_code_file = 'temp.' + language
# with open(temp_source_code_file, 'w') as file:
#     file.write(code)


# parser = initialize_parser(temp_source_code_file)

# # Read the source code
# temp_source_code = read_source_code(temp_source_code_file)
# tree = parser.parse(bytes(temp_source_code, 'utf8'))

# # Extract functions, globals, and headers
# parsed_info = extract_functions_globals_headers(temp_source_code, tree)

# Print the extracted information
# print_information(parsed_info)

# delete the temporary file
# os.remove(temp_source_code_file)
    